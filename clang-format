#!/bin/bash

# System-wide clang-format replacement script
# 
# Usage:
#   clang-format                                                 # Format all C/C++ files in current directory tree
#   clang-format file.cpp                                        # Format specific file with default version
#   clang-format CLANG-VERSION                                   # Format all files with specific version
#   clang-format CLANG-VERSION file.cpp                          # Format specific file with specific version
#   clang-format CLANG-VERSION file1.cpp file2.hpp              # Format multiple files
#   clang-format CLANG-VERSION file.cpp --suffix "-clang18"     # Save with suffix
#
# Examples:
#   clang-format                          # Format all C/C++ files with version 19
#   clang-format 18                       # Format all C/C++ files with version 18
#   clang-format example.cpp              # Format specific file with version 19
#   clang-format 18 example.cpp           # Format specific file with version 18
#   clang-format 14 src/*.cpp src/*.h     # Format multiple files with version 14
#   clang-format 18 main.cpp --suffix="-formatted"  # Save copy with suffix

# Default clang-format version and binary path
DEFAULT_VERSION=19

# Function to find all C/C++ files in current directory and subdirectories
find_cpp_files() {
    find . -type f \( -name '*.cpp' -o -name '*.hpp' -o -name '*.c' -o -name '*.h' -o -name '*.cc' -o -name '*.cxx' -o -name '*.hxx' \) 2>/dev/null
}

# Function to show help
show_help() {
    echo "üé® System-wide clang-format replacement"
    echo ""
    echo "Usage:"
    echo "  $0                                           # Format all C/C++ files (default: v$DEFAULT_VERSION)"
    echo "  $0 CLANG-VERSION                            # Format all files with specific version"
    echo "  $0 file.cpp                                 # Format specific file (default: v$DEFAULT_VERSION)"
    echo "  $0 CLANG-VERSION file.cpp                   # Format specific file with version"
    echo "  $0 CLANG-VERSION file1.cpp file2.hpp        # Format multiple files"
    echo "  $0 CLANG-VERSION file.cpp --suffix \"-fmt\"   # Save with suffix"
    echo ""
    echo "Examples:"
    echo "  $0                              # Format all C/C++ files in tree"
    echo "  $0 18                           # Format all files with clang-format-18"
    echo "  $0 example.cpp                  # Format specific file"
    echo "  $0 18 example.cpp               # Format with clang-format-18"
    echo "  $0 14 src/*.cpp --suffix \"-fmt\" # Save formatted copies"
    echo ""
    echo "Available versions:"
    if ls clang-format-* >/dev/null 2>&1; then
        ls -1 clang-format-* | sed "s|clang-format-|  |"
    elif ls bin/clang-format-* >/dev/null 2>&1; then
        ls -1 bin/clang-format-* | sed 's/.*clang-format-/  /'
    else
        echo "  No binaries found. Install or build clang-format versions first."
    fi
}

# Parse arguments
CLANG_VERSION=""
FILES=()
SUFFIX=""
FORMAT_ALL=false

# Handle special cases for suffix parsing
args=("$@")
for i in "${!args[@]}"; do
    if [[ "${args[i]}" == "--suffix="* ]]; then
        SUFFIX="${args[i]#--suffix=}"
        unset args[i]
    elif [[ "${args[i]}" == "--suffix" ]] && [[ -n "${args[i+1]}" ]]; then
        SUFFIX="${args[i+1]}"
        unset args[i] args[$((i+1))]
    fi
done

# Rebuild args array
args_clean=()
for arg in "${args[@]}"; do
    [[ -n "$arg" ]] && args_clean+=("$arg")
done

# Parse cleaned arguments
for arg in "${args_clean[@]}"; do
    if [ "$arg" = "--help" ] || [ "$arg" = "-h" ]; then
        show_help
        exit 0
    elif [[ "$arg" =~ ^[0-9]+$ ]]; then
        # Numeric argument is version
        if [ -z "$CLANG_VERSION" ]; then
            CLANG_VERSION="$arg"
        else
            echo "‚ùå Multiple versions specified: $CLANG_VERSION and $arg"
            exit 1
        fi
    elif [ -f "$arg" ] || [[ "$arg" == *"."* ]]; then
        # File arguments
        FILES+=("$arg")
    else
        echo "‚ùå Unknown argument: $arg"
        show_help
        exit 1
    fi
done

# Determine behavior based on arguments
if [ ${#args_clean[@]} -eq 0 ]; then
    # No arguments: format all files with default version
    CLANG_VERSION="$DEFAULT_VERSION"
    FORMAT_ALL=true
elif [ ${#args_clean[@]} -eq 1 ] && [[ "${args_clean[0]}" =~ ^[0-9]+$ ]]; then
    # Single numeric argument: format all files with specified version
    FORMAT_ALL=true
elif [ ${#FILES[@]} -eq 0 ]; then
    # No files specified but have other args
    echo "‚ùå No files specified"
    show_help
    exit 1
fi

# Set default version if not specified
if [ -z "$CLANG_VERSION" ]; then
    CLANG_VERSION="$DEFAULT_VERSION"
fi

# If formatting all files, find them
if [ "$FORMAT_ALL" = true ]; then
    echo "üîç Finding all C/C++ files in current directory tree..."
    readarray -t FILES < <(find_cpp_files)
    if [ ${#FILES[@]} -eq 0 ]; then
        echo "‚ùå No C/C++ files found in current directory tree"
        exit 1
    fi
fi

# Find the clang-format binary
BINARY=""
if [ -f "clang-format-$CLANG_VERSION" ]; then
    BINARY="clang-format-$CLANG_VERSION"
elif [ -f "bin/clang-format-$CLANG_VERSION" ]; then
    BINARY="bin/clang-format-$CLANG_VERSION"
else
    echo "‚ùå clang-format-$CLANG_VERSION not found"
    echo "Available versions:"
    if ls clang-format-* >/dev/null 2>&1; then
        ls -1 clang-format-* | sed "s|clang-format-|  |"
    elif ls bin/clang-format-* >/dev/null 2>&1; then
        ls -1 bin/clang-format-* | sed 's/.*clang-format-/  /'
    else
        echo "  No binaries found."
    fi
    exit 1
fi

# Process files
if [ "$FORMAT_ALL" = true ]; then
    echo "üé® Formatting ${#FILES[@]} C/C++ file(s) in directory tree with clang-format-$CLANG_VERSION..."
else
    echo "üé® Formatting ${#FILES[@]} specified file(s) with clang-format-$CLANG_VERSION..."
fi

SUCCESS_COUNT=0
ERROR_COUNT=0
PROCESSED_FILES=()

for file in "${FILES[@]}"; do
    # Handle glob patterns
    if [[ "$file" == *"*"* ]]; then
        # Expand glob pattern
        expanded_files=()
        for expanded_file in $file; do
            if [ -f "$expanded_file" ]; then
                expanded_files+=("$expanded_file")
            fi
        done
        # Add expanded files to processing list
        PROCESSED_FILES+=("${expanded_files[@]}")
        continue
    fi
    
    PROCESSED_FILES+=("$file")
done

# Process all collected files
for file in "${PROCESSED_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        echo "‚ö†Ô∏è  File not found: $file"
        ((ERROR_COUNT++))
        continue
    fi
    
    # Get relative path for cleaner output
    rel_file="${file#./}"
    
    if [ -n "$SUFFIX" ]; then
        # Save with suffix - insert before file extension
        if [[ "$file" == *.* ]]; then
            # File has extension - insert suffix before it
            base="${file%.*}"
            ext="${file##*.}"
            output_file="${base}${SUFFIX}.${ext}"
        else
            # No extension - append suffix
            output_file="${file}${SUFFIX}"
        fi
        echo "  üìÑ $rel_file ‚Üí ${output_file#./}"
        if $BINARY "$file" > "$output_file"; then
            ((SUCCESS_COUNT++))
        else
            echo "‚ùå Failed to format: $rel_file"
            ((ERROR_COUNT++))
        fi
    else
        # Format in place
        echo "  üìÑ $rel_file"
        if $BINARY -i "$file"; then
            ((SUCCESS_COUNT++))
        else
            echo "‚ùå Failed to format: $rel_file"
            ((ERROR_COUNT++))
        fi
    fi
done

# Summary
echo ""
if [ $ERROR_COUNT -eq 0 ]; then
    echo "‚úÖ Successfully formatted $SUCCESS_COUNT file(s)!"
else
    echo "‚ö†Ô∏è  Completed with $SUCCESS_COUNT success(es) and $ERROR_COUNT error(s)"
    exit 1
fi
